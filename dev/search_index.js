var documenterSearchIndex = {"docs":
[{"location":"Getting_Started/Bases/Basis_Construction/#Basis-Construction","page":"Basis Construction","title":"Basis Construction","text":"","category":"section"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"Individual on and off site bases may be constructed via calls to the on_site_ace_basis and off_site_ace_basis functions respectively. For on-site bases, one must specify six arguments:","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"The azimuthal quantum numbers of the associated shells, ℓ₁ and ℓ₂. For example, ℓ₁, ℓ₂= 0, 1 would correspond to a s-p interaction.\nThe correlation order ν. For on-site interactions the body-order is equivalent to one greater than the correlation order; i.e. a correlation order of one would equate to a body-order of two. \nThe maximum polynomial degree deg commonly a value between 2 and 20. This should be chosen via hyperparmeter optimisation.\nThe environmental cutoff distance e_cut. Only atoms within the specified cutoff radius will contribute to the local environment. A r_cut value of zero would result in predictions being treated as independent of their environment.\nThe scaling parameter r0; this is commonly set to the nearest neighbour distance.","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"ℓ₁, ℓ₂ = 0, 0\nν, deg = 2, 4\ne_cut, r0 = 12.0, 2.5\n\non_site_core_basis = on_site_ace_basis(ℓ₁, ℓ₂, ν, deg, e_cut, r0)","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"The call to the off-site basis constructor is identical to its on-site counterpart. With the exception that a bond distance cutoff is provided in-place of r0. Which, as it name suggests, specifies the maximum distance up to which such interactions will be considered. That is to say only interactions between pairs of atoms separated by a distance less than or equal to b_cut will be evaluated. For off-site interactions the body-order is two greater than the correlation order. ","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"ℓ₁, ℓ₂ = 0, 1\nν, deg = 1, 4\nb_cut, e_cut = 12.0, 5.0\n\noff_site_core_basis = off_site_ace_basis(ℓ₁, ℓ₂, ν, deg, b_cut, e_cut)","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"In order to make use of the these bases one must wrap them in a Basis instance like so:","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"id_on = (6, 1, 1)\nid_off = (6, 6, 1, 2)\non_site_ss_basis = Basis(on_site_core_basis, id_on)\noff_site_sp_basis = Basis(off_site_core_basis, id_off)","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"The first argument is always the SymmetricBasis object returned by the on/off-site ACE basis constructor functions. The second argument is the basis id, this is used to identify what interaction the basis is associated with. An id of the form (z, i, j) indicates a basis represent the on-site interaction between the iᵗʰ and jᵗʰ shells of species z. Whereas an id of the form (z₁, z₂, i, j) indicates the basis represents an off-site interaction between the iᵗʰ shell of species z₁ and the jᵗʰ shell of species z₂. Shell indices are used in place of azimuthal quantum numbers to avoid ambiguities arising from the use of non-minimal basis sets.","category":"page"},{"location":"Getting_Started/Bases/Basis_Construction/","page":"Basis Construction","title":"Basis Construction","text":"These Basis structures contain for members, basis, id, coefficients and mean. With the first two already having been discussed. The latter two coefficients and mean are set during the fitting process and are used only when making predictions.","category":"page"},{"location":"Getting_Started/Bases/Basis_Fitting/#Basis-Fitting","page":"Basis Fitting","title":"Basis Fitting","text":"","category":"section"},{"location":"Getting_Started/Bases/Basis_Fitting/","page":"Basis Fitting","title":"Basis Fitting","text":"Individual Basis instances may be fitted by supplying the Basis and fitting data to the fit! function. This single basis fit! function takes the two aforementioned positional arguments along with three optional keyword arguments: solver which specifies the solver to use during fitting which defaults to LSQR, λ is the degree of regularisation to be applied which defaults to 1E-7, and enable_mean with permits a mean offset to be applied while this defaults to false it is advised to enable it when fitting on-site bases.","category":"page"},{"location":"Getting_Started/Bases/Basis_Fitting/","page":"Basis Fitting","title":"Basis Fitting","text":"\n# Path to the database within which the fitting data is stored\ndatabase_path = \"example_data.h5\"\n\n# Name/path of/to the system to which fitting data should be drawn \ntarget_system = \"0224\"\n\n# Load the real-space Hamiltonian matrix, atoms object, cell translation vectors, and basis set definition\nH, atoms, images, basis_definition = h5open(database_path) do database\n    target = database[target_system]\n    load_hamiltonian(target), load_atoms(target; recentre=true), load_cell_translations(target), load_basis_set_definition(target)\nend\n\n# Get the species of the system - it can be done in several ways and here just comes one\n# This step can be skipped if all atoms in this system are of the same type\nspecies = unique(atoms.Z)\n# Alternatively, one can use \n# using JuLIP\n# species = AtomicNumber.([ keys(basis_definition)... ])\n\n# Construct a pair of on and off-site bases\non_site_basis = Basis(on_site_ace_basis(0, 1, 2, 4, 6.0; species = (try species catch nothing end)), (14, 3, 4))\noff_site_basis = Basis(off_site_ace_basis(1, 1, 1, 4, 8.0, 4.0; species = (try species catch nothing end)), (14, 14, 6, 6))\n\n# Gather all relevant data for fitting \non_site_data = get_dataset(H, atoms, on_site_basis, basis_definition, images)\noff_site_data = get_dataset(H, atoms, off_site_basis, basis_definition, images)\n\n# Perform the fitting operation\n# Here, solver is an optional field with default \"LSQR\" which \n# specifies the solver used to solve the least squares in fitting\n# Other possible choice are \"QR\", \"ARD\", \"BRR\", \"RRQR\" etc.\nfit!(on_site_basis, on_site_data; solver = \"LSQR\")\nfit!(off_site_basis, off_site_data; solver = \"LSQR\")\n","category":"page"},{"location":"Getting_Started/Bases/Basis_Fitting/","page":"Basis Fitting","title":"Basis Fitting","text":"The fitting data must be provided as a DataSet instance. These structures contain all of the data required to carry out the fitting process; specifically the target sub-blocks and state objects required to perform a fitting operation. The get_dataset convenience function auto-collects all relevant data, which can be filtered as and when needed by the user. This avoids users having to manually collect and construct DataSet instances themselves.","category":"page"},{"location":"Getting_Started/Quick_Start/#Introduction","page":"Getting Started","title":"Introduction","text":"","category":"section"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"(Image: alt text)","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The ACEhamiltonians package is a Julia package that provides tools for constructing, fitting, and predicting self-consistent Hamiltonian and overlap matrices in solid-state systems. It is based on the atomic cluster expansion (ACE) approach and the associated ACEsuit package. The ACEhamiltonians package contains functions for generating on-site and off-site basis functions, fitting these bases to theoretical (DFT) data, and predicting the Hamiltonian and overlap matrices for any atomic configuration in real or reciprocal space. ACEhamiltonians provides a flexible and efficient way to model the electronic structure of materials and is a valuable tool for researchers in computational materials science. Please refer to the associated article for a more in-depth description of the methodological underpinnings of this package.","category":"page"},{"location":"Getting_Started/Quick_Start/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"This quick-start guide provides an overview of the ACEhamiltonians framework, including the Model and Basis structures. The Model structure represents a model that includes on-site and off-site bases, their corresponding parameters, and the basis definition, while the Basis structures within represents the interaction between atomic shells in a system. The guide outlines the construction, fitting, and predicting processes for both structures, providing users with an efficient and flexible way to represent interactions in various systems. Links to more detailed documents are also provided as necessary.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"Installation and setup instructions can be found at the end of this document. The example_data.h5 dataset used throughout the examples and documentation has been supplied, and can be downloaded here.","category":"page"},{"location":"Getting_Started/Quick_Start/#Models","page":"Getting Started","title":"Models","text":"","category":"section"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Model struct in the ACEhamiltonians framework represents a model that includes both on-site and off-site bases, their corresponding parameters, and the basis definition. It also contains a label to identify the model and a dictionary for storing any meta-data associated with it.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The model constructor takes in the necessary information, such as the on-site and off-site parameters, and generates the associated on-site and off-site bases for all unique species pairs and their shells. It handles cases with symmetrically equivalent interactions and allows for the use of dual-basis models when necessary (primarily for debugging). The constructor ensures that the model is built with the appropriate bases and parameters, making it ready for fitting and predicting operations.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Model structure in the ACEhamiltonians framework consists of several fields that play a crucial role in defining and utilizing the model. Here is a list of these fields and a brief description of their purpose:","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"on_site_bases: A dictionary that stores the on-site basis functions for each unique species pair and their shells, indexed by a tuple of the form (z₁, n₁, n₂), where z₁ represents the atomic number and n₁ and n₂ are the shell indices.\noff_site_bases: A dictionary that stores the off-site basis functions for each unique species pair and their shells, indexed by a tuple of the form (z₁, z₂, n₁, n₂), where z₁ and z₂ represent the atomic numbers and n₁ and n₂ are the shell indices.\non_site_parameters: An object of the OnSiteParaSet type that contains the on-site parameters for each unique species pair and their shells.\noff_site_parameters: An object of the OffSiteParaSet type that contains the off-site parameters for each unique species pair and their shells.\nbasis_definition: A collection that describes the basis set for each species present in the model, including the atomic number and associated shell information.\nlabel: A string that serves as an identifier for the model, typically indicating the type of matrix being represented (e.g., \"H\" for Hamiltonian or \"S\" for overlap).\nmeta_data: A dictionary that stores any additional meta-data associated with the model. This can include miscellaneous information or attributes that are not directly involved in the model construction, fitting, or prediction processes.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Model Construction section outlines the process of creating an ACEhamiltonians model in Julia. The model is initialised by providing parameters such as model_type, basis_definition, on_site_parameters, and off_site_parameters. The model_type is set to \"H\" or \"S\" depending on whether the model will be fitted to Hamiltonian or overlap matrices. basis_definition specifies the azimuthal quantum numbers, while on_site_parameters and off_site_parameters define the parameters required for constructing on-site and off-site bases respectively. The file also details the various Params type structures (GlobalParams, AtomicParams, AzimuthalParams, and ShellParams) that provide different levels of specificity for parameter declarations. The OnSiteParaSet and OffSiteParaSet structures are used to store all the required parameter definitions for on-site and off-site interactions.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Model Fitting section demonstrates how to use the various fitting subroutines within the ACEhamiltonians framework to fit a model. With the model-level automated fitting procedure, you only need to specify the model to be fitted and the location(s) for gathering fitting data. The fit! function performs the fitting operation and accepts several optional keyword arguments for customization. You can also manually select fitting data by placing it into a dictionary keyed by basis id and providing it to the fitting function along with the model. In this case, you only need to provide data for the bases you want to fit.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"Finally, the Model Predicting section illustrates how to make predictions using the predict methods.  To create the real-space matrix for a system, call the predict method with a model, an Atoms entity representing the system, and the cell translation vectors. You can then use the real-space matrix to construct the complex matrix at a specific k-point with the real_to_complex method. The cell translation vectors determine which cells are included when constructing the real-space matrix. You can use the cell_translations method to estimate them based on the distance cut-offs within the model.","category":"page"},{"location":"Getting_Started/Quick_Start/#Bases","page":"Getting Started","title":"Bases","text":"","category":"section"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Basis structure is a key component of the ACEHamiltonians framework, representing the interaction between atomic shells in a system. It is constructed from on-site or off-site ACE basis functions and contains a unique identifier (id) for the specific interaction. Once fitted, the Basis structure holds coefficients and mean values used for making predictions. It is a flexible and efficient way to represent interactions in various systems, making it an essential part of the model fitting and prediction process.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"Typically, creating isolated Basis instances isn't commonly required, as the Model encompasses the essential functionality for constructing and applying bases. However, working with individual Basis instances can be beneficial during hyperparameter optimization and are therefore discussed here.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Basis Construction section explains how to create individual on-site and off-site bases using the on_site_ace_basis and off_site_ace_basis functions, respectively. The process involves specifying necessary parameters such as quantum numbers, correlation order, maximum polynomial degree, and cutoff distances. After creating the core basis, it is wrapped in a Basis instance, which associates the basis with an interaction and provides an identifier. The Basis structure is utilized during the fitting process and when making predictions.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Basis Fitting section explains how to fit individual Basis instances by providing the basis and fitting data to the fit! function. The function requires a DataSet instance containing all necessary data for the fitting process. The get_dataset convenience function automatically collects all relevant data, simplifying the fitting operation. The fitting process involves loading the real-space Hamiltonian matrix, atoms object, cell translation vectors, and basis set definition, and then performing the fitting operation on the bases.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The Basis Predicting section describes how to make predictions for individual bases using the predict function. By providing a Basis instance and a state-vector (a vector of AbstractState instances), predictions can be made for on-site and off-site interactions. The example demonstrates how to load an atoms object, obtain the on-site and off-site states representing the environment, and make predictions for these states. Predictions can also be made for multiple blocks simultaneously by providing a vector containing multiple state-vectors.","category":"page"},{"location":"Getting_Started/Quick_Start/#Installation-and-Setup","page":"Getting Started","title":"Installation and Setup","text":"","category":"section"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"The ACEhamiltonians package can be installed in either general user mode or development mode. User mode installs the package into the .julia/packages/ directory, allowing it to be imported and used as any other Julia package. In contrast, development mode sets up ACEhamiltonians as a repository that can be modified as needed, making it the currently recommended option. To get started using ACEhamiltonians in user mode, simply start a Julia session and issue the relevant commands as provided in the following code-block. To install ACEhamiltonians for development purposes, follow the instructions provided in the following development sub-section.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"using Pkg\n# Add MolSim registry\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/JuliaMolSim/MolSim.git\"))\n# Readd the \"General\" registry to ensure stability\nPkg.Registry.add(\"General\")\n# Finally add the ACEhamiltonians package\nPkg.add(url=\"https://github.com/ACEsuit/ACEhamiltonians.jl.git\", ref=\"Development\")","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"Then verify the installation by starting a new Julia session and issue \"using ACEhamiltonians\" to import and build the package.","category":"page"},{"location":"Getting_Started/Quick_Start/#Development","page":"Getting Started","title":"Development","text":"","category":"section"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"To download, install, and set up ACEhamiltonians for development purposes, follow these steps:","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"In the terminal, create a working directory and cd into it. Clone the repository and checkout the development branch. Then start a julia session using the newly cloned repository as the working directory.\n# Make a working directory (called ACEhamiltonians in this example) and cd into it \nmkdir ACEhamiltonians && cd \"$_\"\n\n# Clone the ACEhamiltonians repository and checkout the Development branch\ngit clone git@github.com:ACEsuit/ACEhamiltonians.jl.git --branch Development\n\n# Start a Julia session using the ACEhamiltonians package as the project/environment.\njulia --project=ACEhamiltonians.jl \nWithin the Julia session, execute the following code. This will make the required registries available, instantiate the package, and mark it as a developmental package.\nusing Pkg\n\n# Add MolSim registry\nPkg.Registry.add(RegistrySpec(url=\"https://github.com/JuliaMolSim/MolSim.git\"))\n\n# Readd the \"General\" registry to ensure stability\nPkg.Registry.add(\"General\")\n\n# Instantiate the environment from the `Manifest.toml` and or `Project.toml` files.\nPkg.instantiate()\n\n# Deactivate the current Julia environment (to permit the next command)\nPkg.activate()\n\n# Make the ACEhamiltonians package available for development.\nPkg.develop(path=\"./ACEhamiltonians.jl\")\nFinally, check that the ACEhamiltonians package is accessible by starting a new Julia session and issuing \"using ACEhamiltonians\" to import and build the package.","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"Some static package level development configuration options are made available in the ACEhamiltonians.jl source file. These options are as follows:","category":"page"},{"location":"Getting_Started/Quick_Start/","page":"Getting Started","title":"Getting Started","text":"DUAL_BASIS_MODEL: if set to true the off-site hetro-orbital interactions will be represented by a pair of bases; i.e. sp and ps. Predictions will then be made by averaging the results of the two models like so sp(AB) = 05cdot(sp(AB) + ps(BA)^T). While this is somewhat redundant it does help aviate some current stability issues. This is set to true by default.\nBOND_ORIGIN_AT_MIDPOINT: if set to true the point of the bond will be used as the origin for the off-site states objects. This is disabled by default as a when an environmental atom lies exactly at the midpoint spherical angles θ and ϕ become indeterminate and thus a direction cannot be determined. This results in violations of bond symmetry.\nSYMMETRY_FIX_ENABLED: if set to true then a symmetry fix will be applied to homo-azimuthal interactions to force them to respect transposition symmetry. This is disabled by default as it is only valid when the bond origin lies at the midpoint.","category":"page"},{"location":"Getting_Started/Bases/Basis_Predicting/#Basis-Predicting","page":"Basis Predicting","title":"Basis Predicting","text":"","category":"section"},{"location":"Getting_Started/Bases/Basis_Predicting/","page":"Basis Predicting","title":"Basis Predicting","text":"Predictions can be made for individual bases by providing a Basis instance along with a state-vector (a vector of AbstractState instance) to the predict function.","category":"page"},{"location":"Getting_Started/Bases/Basis_Predicting/","page":"Basis Predicting","title":"Basis Predicting","text":"\n\n# System upon which predictions are to be made.\ndatabase_path = \"example_data.h5\"\ntarget_system = \"0224\"\n\n# Load the atoms object\natoms = h5open(database_path) do database\n    load_atoms(database[target_system]; recentre=true)\nend\n\n# Get the on-site state representing the environment about atom 1\non_site_state = get_state(1, atoms)\n\n# Get the off-site state representing the environment about the bond\n# between atom 1 in the origin cell and atom 2 in image [0, 0, 1].\noff_site_state = get_state(1, 2, atoms, envelope(off_site_basis), [0, 0, 1])\n\n# Make the predictions\non_site_block = predict(on_site_basis, on_site_state)\noff_site_block = predict(off_site_basis, off_site_state)","category":"page"},{"location":"Getting_Started/Bases/Basis_Predicting/","page":"Basis Predicting","title":"Basis Predicting","text":"Predictions can also be made for multiple blocks simultaneously by providing a vector containing multiple state-vectors.","category":"page"},{"location":"Getting_Started/Model/Model_Fitting/#Model-Fitting","page":"Model Fitting","title":"Model Fitting","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Fitting/","page":"Model Fitting","title":"Model Fitting","text":"The ACEhamiltonians framework offers a variety of fitting subroutines which are capable of anything from a single basis to an entire model. When using the model-level automated fitting procedure, one need only specify the model to be fitted and the location(s) from which fitting data can be gathered. Model-level fitting can be carried out with only a few lines of code, as evident from the following example. ","category":"page"},{"location":"Getting_Started/Model/Model_Fitting/","page":"Model Fitting","title":"Model Fitting","text":"# Path to the database within which the fitting data is stored\ndatabase_path = \"example_data.h5\"\n\n# Names/paths of/to the system(s) to which the model should draw fitting data\ntarget_systems = [\"0224\"]\n\n# Open up the HDF5 database within which the target data is stored\nh5open(database_path) do database\n\n    # Load the target system(s) for fitting\n    systems = [database[target_system] for target_system in target_systems]\n\n    # Perform the fitting operation\n    # Here, solver is an optional field with default \"LSQR\" which \n    # specifies the solver used to solve the least squares in fitting\n    # Other possible choice are \"QR\", \"ARD\", \"BRR\", \"RRQR\" etc.\n    fit!(model, systems; recentre=true, solver = \"LSQR\")\nend\n\n# Don't forget to save the model after fitting (if needed)","category":"page"},{"location":"Getting_Started/Model/Model_Fitting/","page":"Model Fitting","title":"Model Fitting","text":"This particular version of fit! requires only two positional arguments, but accepts up to six optional keyword arguments. The first positional argument is the Model to be fitted and the second is a vector of HDF5 Group object(s) from which the fitting data is to be drawn. It is important to note that the provided HDF5 groups must follow the structure specification provided here. The optional keyword arguments made available are:","category":"page"},{"location":"Getting_Started/Model/Model_Fitting/","page":"Model Fitting","title":"Model Fitting","text":"on_site_filter::Function: the DataSet entities for all on-site bases will be passed through this filter function prior to fitting. This function should take as DataSet as its only argument and yield a, possibly filtered, DataSet as its return. If not specified this will default to identity.\noff_site_filter::Function: off-site equivalent to the on_site_filter argument.\ntolerance::AbstractFloat: only sub-blocks with least one element greater than or equal to tolerance will be loaded. This argument permits sparse blocks to be ignored during loading and fitting. Warning, this can negatively impact the performance of the off-site bases if the bond cutoff distance was not chosen with care and is therefore disabled by default. \nrecentre::Bool: By default, atoms loaded from the database are assumed to span the fractional coordinate domain of [0.0, 1.0). Setting recentre to true will remap atomic positions to the fractional coordinate domain of [-0.5, 0.5). This is used to ensure that atomic coordinates are consistent with the geometry layout used internally by FHI-aims. This is disabled by default and should only be used when loading real-space matrices generated by FHI-aims. \nrefit::Bool: By default already fitted bases will not be refitted, but this behaviour can be suppressed by setting refit=true.\ntarget::String: a string indicating which matrix should be fitted. This may be either H or S. If unspecified then the model's .label field will be read and used.","category":"page"},{"location":"Getting_Started/Model/Model_Fitting/#Manual-Fitting","page":"Model Fitting","title":"Manual Fitting","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Fitting/","page":"Model Fitting","title":"Model Fitting","text":"Alternatively, one may manually select the fitting data and place it into a dictionary keyed by basis id (Dict(basis_id, DataSet)). This is then provided to the fitting function along with the model like so fit!(model, fitting_data_dictionary). Note that one need only provide data for the bases that one wishes to fit. ","category":"page"},{"location":"Getting_Started/Data/Database_Structure/#Database-Structure","page":"Database Structure","title":"Database Structure","text":"","category":"section"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"The ACEhamiltonians.IO module contains a series of functions that are intended to aid in the loading of data from HDF5 structured databases. While this module offers read functionally is does not offer any write subroutines as of the time of writing. Furthermore, all loading methods are hard-code to look for the requested data in a specific location relative to top level group of each system.   Thus a all HDF5 databases must strictly adhere to specified file structure specification to be readable.","category":"page"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"A brief outline of the expected HDF5 database structure is provided below. Note that arrays must be stored in column major format and names are case sensitive!","category":"page"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"Database\n├─System_1\n│ ├─Structure\n│ │ ├─atomic_numbers:\n│ │ │   > A vector of integers specifying the atomic number of each atom present in the\n│ │ │   > target system. Read by the function `load_atoms`.\n│ │ │\n│ │ ├─positions:\n│ │ │   > A 3×N matrix, were N is the number of atoms present in the system, specifying\n│ │ │   > cartesian coordinates for each atom. Read by the function `load_atoms`.\n│ │ │\n│ │ ├─lattice:\n│ │ │   > A 3×3 matrix specifying the lattice systems lattice vector in column-wise\n│ │ │   > format; i.e. columns loop over vectors. Read by the function `load_atoms`\n│ │ │   > if and when present.\n│ │ │\n│ │ └─pbc:\n│ │     > A boolean, or a vector of booleans, indicating if, or along which dimensions,\n│ │     > periodic conditions are enforced. This is only read when the lattice is given. \n│ │     > This defaults to true for non-molecular/cluster cases. Read by `load_atoms`.\n│ │\n│ ├─Info\n│ │ ├─Basis:\n│ │ │   > This group contains one dataset for each species that specifies the \n│ │ │   > azimuthal quantum numbers of each shell present on that species. Read\n│ │ │   > by the `load_basis_set_definition` method.\n│ │ │\n│ │ │\n│ │ ├─Translations:\n│ │ │   > A 3×N matrix specifying the cell translation vectors associated with the real \n│ │ │   > space Hamiltonian & overlap matrices. Only present when Hamiltonian & overlap\n│ │ │   > matrices are given in their M×M×N real from. Read by `load_cell_translations`.\n│ │ │   > Should be integers specifying the cell indices, rather than cartesian vectors.\n│ │ │   > The origin cell, [0, 0, 0], must always be first!\n│ │ │ \n│ │ └─k-points:\n│ │     > A 4×N matrix where N is the number of k-points. The first three rows specify\n│ │     > k-points themselves with the final row specifying their associated weights.\n│ │     > Read by `load_k_points_and_weights`. Only present for multi-k-point calculations. \n│ │\n│ └─Data\n│   ├─H:\n│   │   > The Hamiltonian. Either an M×M matrix or an M×M×N real-space tensor; where M is \n│   │   > is the number of orbitals and N then number of primitive cell equivalents. Read\n│   │   > in by the `load_hamiltonian` function.\n│   │\n│   ├─S:\n│   │   > The Overlap matrix; identical in format to the Hamiltonian matrix. This is read\n│   │   > in by the `load_overlap` function.\n│   │\n│   ├─total_energy:\n│   │   > A single float value specifying the total system energy.\n│   │\n│   ├─fermi_level:\n│   │   > A single float value specifying the total fermi level.\n│   │\n│   ├─forces:\n│   │   > A 3×N matrix specifying the force vectors on each atom.\n│   │\n│   ├─H_gamma:\n│   │   > This can be used to store the gamma point only Hamiltonian matrix when 'H' is\n│   │   > used to store the real space matrix. This is mostly for debugging & testing.\n│   │\n│   └─S_gamma:\n|       > Overlap equivalent of `H_gamma`\n│\n├─System_2\n│ ├─Structure\n│ │ └─ ...\n│ │\n│ ├─Info\n│ │ └─ ...\n│ │\n│ └─Data\n│   └─ ...\n...\n└─System_n\n  └─ ...","category":"page"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"When calling the various load methods within DatabaseIO the src Group argument must always point to the target systems top level Group. In the example structure tree given above these would be 'System1', 'System2', and 'System_n'. Datasets and groups should provide information about what units the data they contain are given in. This can be done through the of the HDF5 metadata attributes. However, units are not yet fully supported. ","category":"page"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"An example is provided below demonstrating how one may load data from a HDF5 database.","category":"page"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"# Path to the database from which data is to be loaded\ndatabase_path = \"/home/ajmhpc/Documents/Work/Projects/ACEtb/Data/Si/Construction/example_data.h5\"\n# Path, relative to the top level, to the group from which data is to be extracted\ntarget_system = \"0224\"\n\n# Open the HDF5 database file \nH, S, atoms, images = h5open(database_path) do database\n    # Select the target group\n    target = database[target_system]\n    # Load the Hamiltonian and overlap matrices followed by the atoms object\n    # and the cell translation vectors\n    (load_hamiltonian(target), load_overlap(target), \n    load_atoms(target; recentre=true), load_cell_translations(target))\nend","category":"page"},{"location":"Getting_Started/Data/Database_Structure/","page":"Database Structure","title":"Database Structure","text":"A python script (aims_database_builder.py) is provided in the tools directory which demonstrates how such a database may be constructed from the output of an FHI-aims calculation.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Model-Construction","page":"Model Construction","title":"Model Construction","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"An ACEhamiltonians model can be created, as shown below, by constructing and passing the required parameters to the model factory.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"# 1) Provide a label for the model (this should be H or S)\nmodel_type = \"H\"\n\n# 2) Definition of a s₃p₃d₁ silicon basis\nbasis_definition = BasisDef{Int64}(14=>[0, 0, 0, 1, 1, 1, 2])\n\n# 3) On-site parameter deceleration\non_site_parameters = OnSiteParaSet(\n    # Maximum correlation order\n    GlobalParams(2),\n    # Maximum polynomial degree\n    GlobalParams(6),\n    # Environmental cutoff radius\n    GlobalParams(10.),\n    # Scaling factor \"r₀\"\n    GlobalParams(2.5)\n)\n\n# 4) Off-site parameter deceleration\noff_site_parameters = OffSiteParaSet(\n    # Maximum correlation order\n    GlobalParams(1),\n    # Maximum polynomial degree\n    GlobalParams(6),\n    # Bond cutoff radius\n    GlobalParams(10.),\n    # Environmental cutoff radius\n    GlobalParams(5.),\n)\n\n# 5) Initialise the model\nmodel = Model(basis_definition, on_site_parameters, off_site_parameters, model_type)","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"The model factory takes four arguments, namely;","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"model_type:  a string used to inform the auto-fitting code of what data to load and use during the fitting operation. This is commonly set to either \"H\" or \"S\" depending on whether one intends to fit the model to Hamiltonian or overlap matrices.\nbasis_definition: a dictionary specifying the azimuthal quantum numbers, ℓ, of each shell present on each of the species to be modelled. The dictionary is keyed by atomic numbers and valued by vectors of ℓ i.e. Dict{atomic_number, [ℓ₁, ..., ℓᵢ]}.  A minimal basis set for hydrocarbon systems would be BasisDef{Int64}(1=>[0], 6=>[0, 0, 1]). This declares hydrogen atoms as having only a single s-shell and carbon atoms as having two s-shells and one p-shell. In reality a regular julia dictionary can be used so long as it has the correct structure.\non_site_parameters: is an OnSiteParaSet structure, which as name suggests, specifies all of the parameters required to construct the on-site bases. Specifically the correlation order, maximum polynomial degree, environmental cutoff radius, and the scaling parameter. Further information on the OnSiteParaSet and the Params structures used in its construction can be found here and here respectively.\noff_site_parameters: is an OffSiteParaSet structure which similarly specifies the parameters for constructing the off-site bases. This provides the correlation order, maximum polynomial degree, bond cutoff distance, and environmental cutoff radius. Again, Params structures are used in the construction of these instances.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Models can be saved to and loaded from JSON files using the commands save_json(\"file_name.json\", write_dict(model)) and read_dict(load_json(\"file_name.json\")) respectively. Although these files are stable and transportable they are also incredibly slow to work with. As such it is strongly advised to use the Serialization module to load and save models timidly manner when working locally. However, such binary files can only be reliably loaded on the system that was used to create them.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Parameters","page":"Model Construction","title":"Parameters","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/#Declarations","page":"Model Construction","title":"Declarations","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Prior to constructing a model one must specify the parameters to be used in its construction. This is done primarily through the use of dictionary-like Params structures, which are collected into ParaSet instances as required. These are used exclusively to provide the parameters needed when constructing models within the ACEhamiltonians framework, or more specifically their underlying bases. There are currently four Params type structures, namely GlobalParams, AtomicParams, AzimuthalParams, and ShellParams, each offering varying levels of specificity.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Each parameter, correlation order, maximum polynomial degree, environmental cutoff distance, etc. may be specified using any of the available Params based structures. However, i) each Params instance may represent one, and only one, parameter, and ii) on-site and off-site parameters must not be mixed.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Global","page":"Model Construction","title":"Global","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"A GlobalParams instance is used to indicate that a single value should be used for all relevant interactions. Querying such instances will always return the value the specified constant value, irrespective of the key, so long as the query is valid.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"julia> p = GlobalParams(2)\nGlobalParams{Int64} with 1 entries:\n  All => 2\n\njulia> ν[1] # <- query parameter associated with H\n2\njulia> ν[(1, 6)] # <- query parameter associated with H-C interaction\n2\njulia> ν[(1, 6, 1, 2)] # <- interaction between 1ˢᵗ shell on H and 2ⁿᵈ shell on C\n2","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"As can be seen, the specified value, 2, will always be returned so long as the query is valid. These instances are useful when specifying parameters that are constant across all bases, such as the correlation order, as it avoids having to repeatedly specify it for each and every interaction.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Species-Resolved","page":"Model Construction","title":"Species Resolved","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"These instances allow for parameters to be specified on a species by species basis. This equates to one parameter per species for on-site interactions and one parameter per species pair for off-site interactions. This will then result in all associated bases associated with a specific species/species-pair all using a common value, like so: ","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"julia> p_on  = AtomicParams(1=>9., 6=>11.)\nAtomicParams{Float64} with 2 entries:\n  6 => 11.0\n  1 => 9.0\n\njulia> p_off = AtomicParams((1, 1)=>9., (1, 6)=>10., (6, 6)=>11.)\nAtomicParams{Float64} with 3 entries:\n  (6, 6) => 11.0\n  (1, 6) => 10.0\n  (1, 1) => 9.0\n\n# The value 11. is returned for all on-site C interaction queries \njulia> p_on[(6, 1, 1)] == p_on[(6, 1, 2)] == p_on[(6, 2, 2)] == 11.\ntrue\n# The value 10. is returned for all off-site H-C interaction queries \njulia> p_off[(1, 6, 1, 1)] == p_off[(6, 1, 2, 1)] == p_off[(6, 1, 2, 2)] == 10.\ntrue","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"These instances are instantiated in a similar manner to dictionaries and offer a finer degree of control over the parameters than GlobalParams structures but are not as granular as their AzimuthalParams counterparts.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"It is important to note that atom pair keys are permutationally invariant, i.e. the keys (1, 6) and (6, 1) are redundant and will overwrite one another like so:","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"julia> test = AtomicParams((1, 6)=>10., (6, 1)=>1000.)\nAtomicParams{Float64} with 1 entries:\n  (1, 6) => 1000.0\n\njulia> test[(1, 6)] == test[(6, 1)] == 1000.0\ntrue","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Finally atomic numbers will be sorted so that the lowest atomic number comes first. However, this is only a superficial visual change and queries will still be invariant to permutation.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Azimuthal-Resolved","page":"Model Construction","title":"Azimuthal Resolved","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Parameters specified for each azimuthal quantum number of each species. This allows for a finer degree of control and is a logical extension of the AtomicParams structure. It is important to note that AzimuthalParams instances must be supplied with a basis definition. This allows it to work out the azimuthal quantum number associated with each shell during lookup.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"# Basis definition describing a H_1s C_2s1p basis set\njulia> basis_def = Dict(1=>[0], 6=>[0, 0, 1])\njulia> p_on = AzimuthalParams(\n    basis_def, (1, 0, 0)=>1, (6, 0, 0)=>2, (6, 0, 1)=>3, (6, 1, 1)=>4)\nAzimuthalParams{Int64} with 4 entries:\n  (6, 0, 0) => 2\n  (1, 0, 0) => 1\n  (6, 1, 1) => 4\n  (6, 0, 1) => 3\n\njulia> p_off = AzimuthalParams(\n    basis_def, (1, 1, 0, 0)=>1, (6, 6, 0, 0)=>2, (6, 6, 0, 1)=>3, (6, 6, 1, 1)=>4,\n    (1, 6, 0, 0)=>6, (1, 6, 0, 1)=>6)\n\nAzimuthalParams{Int64} with 6 entries:\n    (1, 6, 0, 1) => 6\n    (6, 6, 0, 1) => 3\n    (1, 6, 0, 0) => 6\n    (1, 1, 0, 0) => 1\n    (6, 6, 1, 1) => 4\n    (6, 6, 0, 0) => 2\n\n# on-site interactions involving shells 1 % 2 will return 2 as they're both s-shells.\njulia> p_on[(6, 1, 1)] == p_on[(6, 1, 2)] == p_on[(6, 2, 2)] == 2\ntrue","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"While keys are agnostic to the ordering of the azimuthal numbers; the first atomic number z₁ will always correspond to the first azimuthal number ℓ₁, i.e.:","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"(z₁, ℓ₁, ℓ₂) == (z₁, ℓ₂, ℓ₁)\n(z₁, z₂, ℓ₁, ℓ₂) == (z₂, z₁, ℓ₂, ℓ₁)\n(z₁, z₂, ℓ₁, ℓ₂) ≠ (z₁, z₂ ℓ₂, ℓ₁)\n(z₁, z₂, ℓ₁, ℓ₂) ≠ (z₂, z₁ ℓ₁, ℓ₂)","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Shell-Resolved","page":"Model Construction","title":"Shell Resolved","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"ShellParams structures allow for individual values to be provided for each and everyunique interaction. While this proved the finest degree of control it can quickly become untenable for systems with large basis sets or multiple species due the shear number of variable required.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"# For H1s C2s1p basis set.\njulia> p_on = ShellParams(\n    (1, 1, 1)=>1, (6, 1, 1)=>2, (6, 1, 2)=>3, (6, 1, 3)=>4,\n    (6, 2, 2)=>5, (6, 2, 3)=>6, (6, 3, 3)=>7)\n\nShellParams{Int64} with 7 entries:\n  (6, 3, 3) => 7\n  (1, 1, 1) => 1\n  (6, 1, 3) => 4\n  (6, 2, 2) => 5\n  (6, 1, 1) => 2\n  (6, 1, 2) => 3\n  (6, 2, 3) => 6\n\njulia> p_off = ShellParams(\n    (1, 1, 1, 1)=>1, (1, 6, 1, 1)=>2, (1, 6, 1, 2)=>3, (1, 6, 1, 3)=>4,\n    (6, 6, 1, 1)=>5, (6, 6, 1, 2)=>6, (6, 6, 1, 3)=>74, (6, 6, 2, 2)=>8,\n    (6, 6, 2, 3)=>9, (6, 6, 3, 3)=>10)\n\nShellParams{Int64} with 10 entries:\n  (6, 6, 2, 2) => 8\n  (6, 6, 3, 3) => 10\n  (6, 6, 1, 3) => 74\n  (1, 1, 1, 1) => 1\n  (1, 6, 1, 2) => 3\n  (1, 6, 1, 1) => 2\n  (1, 6, 1, 3) => 4\n  (6, 6, 1, 1) => 5\n  (6, 6, 1, 2) => 6\n  (6, 6, 2, 3) => 9\n","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Collections","page":"Model Construction","title":"Collections","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"All of the parameter definitions required to specify a given interaction are collected into ParaSet structures. Once instantiated, the OnSiteParaSet and OffSiteParaSet structures should contain all parameters required to construct all of the desired on/off-site bases.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#On-site","page":"Model Construction","title":"On-site","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"The OnSiteParaSet structure holds all the Params instances required to construct the on-site bases. Such structures are comprised of four parameter fields, each of which is discussed in turn below:","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"ν::Params{K, Int}: correlation order, for on-site interactions the body order is one more than the correlation order.   \ndeg::Params{K, Int}: maximum polynomial degree.\ne_cut_out::Parameters{K, Float}: environment's external cutoff distance, only atoms within the specified radius will contribute to the local environment. \nr0::Parameters{K, Float}: scaling parameter (typically set to the nearest neighbour distances).","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"An example demonstrating the instantiateation of a simple OffSiteParaSet structure is now provided. ","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"# On-site parameter deceleration\non_site_parameters = OnSiteParaSet(\n    # Maximum correlation order, set to 2 for all on-site bases\n    GlobalParams(2),\n    # Maximum polynomial degree, set to 6 for all on-site bases\n    GlobalParams(6),\n    # Environmental cutoff radius, set to 10.0 Å for all on-site bases\n    GlobalParams(10.),\n    # Scaling factor \"r₀\", set to 2.5 Å for all on-site bases\n    GlobalParams(2.5)\n)","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#Off-site","page":"Model Construction","title":"Off-site","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Likewise, the OffSiteParaSet structures store all parameters required to construct all of the off-site bases.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"ν::Params{K, Int}: correlation order, for off-site interactions the body order is two more than the correlation order.   \ndeg::Params{K, Int}: maximum polynomial degree.\nb_cut::Params{K, Float}: cutoff distance for off-site interactions, only bonding interactions between atoms separated by a distance smaller or equal to this will be considered. \ne_cut_out::Params{K, Float}: environment's external cutoff distance, this is also used as the radius for the cylindrical bond envelope.","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"The OffSiteParaSet can be instantiateated in a similar manner to their on-site counterparts like so:","category":"page"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"# Off-site parameter deceleration\noff_site_parameters = OffSiteParaSet(\n    # Maximum correlation order, set to 1 for all off-site bases\n    GlobalParams(1),\n    # Maximum polynomial degree, set to 6 for all off-site bases\n    GlobalParams(6),\n    # Bond cutoff radius, set to 10.0 Å for all off-site interactions\n    GlobalParams(10.),\n    # Environmental cutoff radius, set to 5.0 Å for all off-site interactions\n    GlobalParams(5.),\n)","category":"page"},{"location":"Getting_Started/Model/Model_Construction/#TODO","page":"Model Construction","title":"TODO","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Construction/","page":"Model Construction","title":"Model Construction","text":"Add images showing the on-site and off-site environments.\nDiscuss the individual parameters in more detail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: alt text)","category":"page"},{"location":"#ACEhamiltonians","page":"Home","title":"ACEhamiltonians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ACEhamiltonians package is a Julia package that provides tools for constructing, fitting, and predicting self-consistent Hamiltonian and overlap matrices in solid-state systems. It is based on the atomic cluster expansion (ACE) approach and the associated ACEsuit package. The ACEhamiltonians package contains functions for generating on-site and off-site basis functions, fitting these bases to theoretical (DFT) data, and predicting the Hamiltonian and overlap matrices for any atomic configuration in real or reciprocal space. ACEhamiltonians provides a flexible and efficient way to model the electronic structure of materials and is a valuable tool for researchers in computational materials science. Please refer to the associated article for a more in-depth description of the methodological underpinnings of this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please consult the quick start guide for installation and usage instructions.","category":"page"},{"location":"Getting_Started/Model/Model_Predicting/#Model-Predicting","page":"Model Predicting","title":"Model Predicting","text":"","category":"section"},{"location":"Getting_Started/Model/Model_Predicting/","page":"Model Predicting","title":"Model Predicting","text":"Within the ACEhamiltonians framework, predictions are made via the predict methods. To construct the real space matrix for a given system one may call the predict method and provide it with i) a model with which to make predictions, ii) an JuLIP.Atoms entity representing to system for which predictions are to be made, and iii) the cell translation vectors. The real-space matrix may then be used to construct the complex matrix at a specific k-point via the real_to_complex method.","category":"page"},{"location":"Getting_Started/Model/Model_Predicting/","page":"Model Predicting","title":"Model Predicting","text":"# K-point for which the complex matrix is to be constructed for\nk_point = [ 0,  0,  0]\n\n# Load the JuLIP.Atoms object of the system to make predictions for\natoms = h5open(database_path) do database\n\t# The argument recentre` is only required when requiring comparability\n\t# with the FHI-aims real-space matrix format.\n    load_atoms(database[target_systems[1]]; recentre=true)\nend\n\n# Specify the cell translation vectors; needed when wanting to compute real-space matrices\nimages = cell_translations(atoms, model)\n\n# Predict the real-space matrix\npredicted_real = predict(model, atoms, images)\n\n# Construct the complex matrix\nprdicted_k = real_to_complex(predicted_real, images, k_point)","category":"page"},{"location":"Getting_Started/Model/Model_Predicting/","page":"Model Predicting","title":"Model Predicting","text":"The cell translation vectors control which cells are included when constructing the real space matrix. The cell_translations method can be used to make a reliable estimate based on the distance cutoffs present within the model.","category":"page"}]
}
